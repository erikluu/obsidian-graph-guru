/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/python-shell/index.js
var require_python_shell = __commonJS({
  "node_modules/python-shell/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PythonShell = exports.NewlineTransformer = exports.PythonShellErrorWithLogs = exports.PythonShellError = void 0;
    var events_1 = require("events");
    var child_process_1 = require("child_process");
    var os_1 = require("os");
    var path_1 = require("path");
    var stream_1 = require("stream");
    var fs_1 = require("fs");
    var util_1 = require("util");
    function toArray(source) {
      if (typeof source === "undefined" || source === null) {
        return [];
      } else if (!Array.isArray(source)) {
        return [source];
      }
      return source;
    }
    function extend(obj, ...args) {
      Array.prototype.slice.call(arguments, 1).forEach(function(source) {
        if (source) {
          for (let key in source) {
            obj[key] = source[key];
          }
        }
      });
      return obj;
    }
    function getRandomInt() {
      return Math.floor(Math.random() * 1e10);
    }
    var execPromise = (0, util_1.promisify)(child_process_1.exec);
    var PythonShellError = class extends Error {
    };
    exports.PythonShellError = PythonShellError;
    var PythonShellErrorWithLogs = class extends PythonShellError {
    };
    exports.PythonShellErrorWithLogs = PythonShellErrorWithLogs;
    var NewlineTransformer = class extends stream_1.Transform {
      _transform(chunk, encoding, callback) {
        let data = chunk.toString();
        if (this._lastLineData)
          data = this._lastLineData + data;
        const lines = data.split(os_1.EOL);
        this._lastLineData = lines.pop();
        lines.forEach(this.push.bind(this));
        callback();
      }
      _flush(done) {
        if (this._lastLineData)
          this.push(this._lastLineData);
        this._lastLineData = null;
        done();
      }
    };
    exports.NewlineTransformer = NewlineTransformer;
    var PythonShell2 = class extends events_1.EventEmitter {
      /**
       * spawns a python process
       * @param scriptPath path to script. Relative to current directory or options.scriptFolder if specified
       * @param options
       * @param stdoutSplitter Optional. Splits stdout into chunks, defaulting to splitting into newline-seperated lines
       * @param stderrSplitter Optional. splits stderr into chunks, defaulting to splitting into newline-seperated lines
       */
      constructor(scriptPath, options, stdoutSplitter = null, stderrSplitter = null) {
        super();
        function resolve(type, val) {
          if (typeof val === "string") {
            return PythonShell2[type][val];
          } else if (typeof val === "function") {
            return val;
          }
        }
        if (scriptPath.trim().length == 0)
          throw Error("scriptPath cannot be empty! You must give a script for python to run");
        let self = this;
        let errorData = "";
        events_1.EventEmitter.call(this);
        options = extend({}, PythonShell2.defaultOptions, options);
        let pythonPath;
        if (!options.pythonPath) {
          pythonPath = PythonShell2.defaultPythonPath;
        } else
          pythonPath = options.pythonPath;
        let pythonOptions = toArray(options.pythonOptions);
        let scriptArgs = toArray(options.args);
        this.scriptPath = (0, path_1.join)(options.scriptPath || "", scriptPath);
        this.command = pythonOptions.concat(this.scriptPath, scriptArgs);
        this.mode = options.mode || "text";
        this.formatter = resolve("format", options.formatter || this.mode);
        this.parser = resolve("parse", options.parser || this.mode);
        this.stderrParser = resolve("parse", options.stderrParser || "text");
        this.terminated = false;
        this.childProcess = (0, child_process_1.spawn)(pythonPath, this.command, options);
        ["stdout", "stdin", "stderr"].forEach(function(name) {
          self[name] = self.childProcess[name];
          self.parser && self[name] && self[name].setEncoding(options.encoding || "utf8");
        });
        if (this.parser && this.stdout) {
          if (!stdoutSplitter)
            stdoutSplitter = new NewlineTransformer();
          stdoutSplitter.setEncoding(options.encoding || "utf8");
          this.stdout.pipe(stdoutSplitter).on("data", (chunk) => {
            this.emit("message", self.parser(chunk));
          });
        }
        if (this.stderrParser && this.stderr) {
          if (!stderrSplitter)
            stderrSplitter = new NewlineTransformer();
          stderrSplitter.setEncoding(options.encoding || "utf8");
          this.stderr.pipe(stderrSplitter).on("data", (chunk) => {
            this.emit("stderr", self.stderrParser(chunk));
          });
        }
        if (this.stderr) {
          this.stderr.on("data", function(data) {
            errorData += "" + data;
          });
          this.stderr.on("end", function() {
            self.stderrHasEnded = true;
            terminateIfNeeded();
          });
        } else {
          self.stderrHasEnded = true;
        }
        if (this.stdout) {
          this.stdout.on("end", function() {
            self.stdoutHasEnded = true;
            terminateIfNeeded();
          });
        } else {
          self.stdoutHasEnded = true;
        }
        this.childProcess.on("error", function(err) {
          self.emit("error", err);
        });
        this.childProcess.on("exit", function(code, signal) {
          self.exitCode = code;
          self.exitSignal = signal;
          terminateIfNeeded();
        });
        function terminateIfNeeded() {
          if (!self.stderrHasEnded || !self.stdoutHasEnded || self.exitCode == null && self.exitSignal == null)
            return;
          let err;
          if (self.exitCode && self.exitCode !== 0) {
            if (errorData) {
              err = self.parseError(errorData);
            } else {
              err = new PythonShellError("process exited with code " + self.exitCode);
            }
            err = extend(err, {
              executable: pythonPath,
              options: pythonOptions.length ? pythonOptions : null,
              script: self.scriptPath,
              args: scriptArgs.length ? scriptArgs : null,
              exitCode: self.exitCode
            });
            if (self.listeners("pythonError").length || !self._endCallback) {
              self.emit("pythonError", err);
            }
          }
          self.terminated = true;
          self.emit("close");
          self._endCallback && self._endCallback(err, self.exitCode, self.exitSignal);
        }
        ;
      }
      /**
       * checks syntax without executing code
       * @returns rejects promise w/ string error output if syntax failure
       */
      static checkSyntax(code) {
        return __awaiter(this, void 0, void 0, function* () {
          const randomInt = getRandomInt();
          const filePath = (0, os_1.tmpdir)() + path_1.sep + `pythonShellSyntaxCheck${randomInt}.py`;
          const writeFilePromise = (0, util_1.promisify)(fs_1.writeFile);
          return writeFilePromise(filePath, code).then(() => {
            return this.checkSyntaxFile(filePath);
          });
        });
      }
      static getPythonPath() {
        return this.defaultOptions.pythonPath ? this.defaultOptions.pythonPath : this.defaultPythonPath;
      }
      /**
       * checks syntax without executing code
       * @returns {Promise} rejects w/ stderr if syntax failure
       */
      static checkSyntaxFile(filePath) {
        return __awaiter(this, void 0, void 0, function* () {
          const pythonPath = this.getPythonPath();
          let compileCommand = `${pythonPath} -m py_compile ${filePath}`;
          return execPromise(compileCommand);
        });
      }
      /**
       * Runs a Python script and returns collected messages as a promise.
       * If the promise is rejected, the err will probably be of type PythonShellErrorWithLogs
       * @param scriptPath   The path to the script to execute
       * @param options  The execution options
       */
      static run(scriptPath, options) {
        return new Promise((resolve, reject) => {
          let pyshell = new PythonShell2(scriptPath, options);
          let output = [];
          pyshell.on("message", function(message) {
            output.push(message);
          }).end(function(err) {
            if (err) {
              err.logs = output;
              reject(err);
            } else
              resolve(output);
          });
        });
      }
      /**
       * Runs the inputted string of python code and returns collected messages as a promise. DO NOT ALLOW UNTRUSTED USER INPUT HERE!
       * @param code   The python code to execute
       * @param options  The execution options
       * @return a promise with the output from the python script
       */
      static runString(code, options) {
        const randomInt = getRandomInt();
        const filePath = os_1.tmpdir + path_1.sep + `pythonShellFile${randomInt}.py`;
        (0, fs_1.writeFileSync)(filePath, code);
        return PythonShell2.run(filePath, options);
      }
      static getVersion(pythonPath) {
        if (!pythonPath)
          pythonPath = this.getPythonPath();
        return execPromise(pythonPath + " --version");
      }
      static getVersionSync(pythonPath) {
        if (!pythonPath)
          pythonPath = this.getPythonPath();
        return (0, child_process_1.execSync)(pythonPath + " --version").toString();
      }
      /**
       * Parses an error thrown from the Python process through stderr
       * @param  {string|Buffer} data The stderr contents to parse
       * @return {Error} The parsed error with extended stack trace when traceback is available
       */
      parseError(data) {
        let text = "" + data;
        let error;
        if (/^Traceback/.test(text)) {
          let lines = text.trim().split(os_1.EOL);
          let exception = lines.pop();
          error = new PythonShellError(exception);
          error.traceback = data;
          error.stack += os_1.EOL + "    ----- Python Traceback -----" + os_1.EOL + "  ";
          error.stack += lines.slice(1).join(os_1.EOL + "  ");
        } else {
          error = new PythonShellError(text);
        }
        return error;
      }
      /**
       * Sends a message to the Python shell through stdin
       * Override this method to format data to be sent to the Python process
       * @returns {PythonShell} The same instance for chaining calls
       */
      send(message) {
        if (!this.stdin)
          throw new Error("stdin not open for writing");
        let data = this.formatter ? this.formatter(message) : message;
        if (this.mode !== "binary")
          data += os_1.EOL;
        this.stdin.write(data);
        return this;
      }
      /**
       * Closes the stdin stream. Unless python is listening for stdin in a loop
       * this should cause the process to finish its work and close.
       * @returns {PythonShell} The same instance for chaining calls
       */
      end(callback) {
        if (this.childProcess.stdin) {
          this.childProcess.stdin.end();
        }
        this._endCallback = callback;
        return this;
      }
      /**
       * Sends a kill signal to the process
       * @returns {PythonShell} The same instance for chaining calls
       */
      kill(signal) {
        this.terminated = this.childProcess.kill(signal);
        return this;
      }
      /**
       * Alias for kill.
       * @deprecated
       */
      terminate(signal) {
        return this.kill(signal);
      }
    };
    exports.PythonShell = PythonShell2;
    PythonShell2.defaultPythonPath = process.platform != "win32" ? "python3" : "python";
    PythonShell2.defaultOptions = {};
    PythonShell2.format = {
      text: function toText(data) {
        if (!data)
          return "";
        else if (typeof data !== "string")
          return data.toString();
        return data;
      },
      json: function toJson(data) {
        return JSON.stringify(data);
      }
    };
    PythonShell2.parse = {
      text: function asText(data) {
        return data;
      },
      json: function asJson(data) {
        return JSON.parse(data);
      }
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GraphGuruPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");
var import_python_shell = __toESM(require_python_shell());

// src/settings.ts
var import_obsidian = require("obsidian");
var import_child_process = require("child_process");
var DefaultGuruSettings = {
  openaiAPIKey: "",
  openaiAPIKeyShadow: "",
  pythonInterpreter: "python",
  dependenciesInstalled: false
};
var GraphGuruSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Graph Guru Settings" });
    new import_obsidian.Setting(containerEl).setName("OpenAI API key").setDesc("This key will be used for OpenAI API calls. We cannot see your key. You can get a key from https://beta.openai.com/account/api-keys.").addButton((button) => {
      button.setButtonText("Hide API key");
      button.setCta();
      button.onClick((evt) => {
        let input = containerEl.querySelector("input");
        if (input) {
          if (input.type === "password") {
            input.type = "text";
            button.setButtonText("Hide API key");
          } else {
            input.type = "password";
            button.setButtonText("Show API key");
          }
        }
      });
    }).addText((text) => text.setPlaceholder("API key").setValue(this.plugin.settings.openaiAPIKey).onChange(async (value) => {
      this.plugin.settings.openaiAPIKey = value;
      await this.plugin.saveSettings();
      let input = containerEl.querySelector("input");
      if (input) {
        input.type = "password";
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Python interpreter").setDesc("Path to your python interpreter, e.g. `/usr/bin/python`. If you are using a virtual environment, you can find the path to your python interpreter by running `which python` in your virtual environment. Requires Python 3.9 or higher.").setClass("wideSettingsElement").addText((text) => text.setValue(this.plugin.settings.pythonInterpreter).onChange(async (value) => {
      this.plugin.settings.pythonInterpreter = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Install python dependencies").setDesc("This will modify your environment-use at your own risk.").addButton((button) => {
      button.setButtonText("Install dependencies");
      button.setCta();
      button.onClick((evt) => {
        let interpreter = this.plugin.settings.pythonInterpreter;
        let command = `${interpreter} -u -m pip install --upgrade openai numpy obsidiantools scikit-learn tenacity markdown pymdown-extensions html2text pandas numpy networkx`;
        new import_obsidian.Notice("Installing dependencies; this may take some time...");
        (0, import_child_process.exec)(command, (error, stdout, stderr) => {
          if (error) {
            console.error(`failed to install dependencies: ${error}`);
            new import_obsidian.Notice("Failed to install dependencies, view developer console for details.");
          } else {
            new import_obsidian.Notice("Installed dependencies, view developer console for details.");
            this.plugin.settings.dependenciesInstalled = true;
          }
          console.log(`install stdout: ${stdout}`);
          console.log(`install stderr: ${stderr}`);
        });
      });
    });
  }
};

// src/main.ts
var { spawn: spawn2 } = require("child_process");
var GraphGuruPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.initBool = false;
  }
  async onload() {
    if (this.app.vault.adapter instanceof import_obsidian2.FileSystemAdapter) {
      this.baseVaultPath = this.app.vault.adapter.getBasePath();
      this.pythonScriptsPath = this.baseVaultPath + "/.obsidian/plugins/obsidian-graph-guru/src/python_scripts/script.py";
    }
    this.settings = Object.assign({}, DefaultGuruSettings, await this.loadData());
    await this.saveSettings();
    this.addSettingTab(new GraphGuruSettingTab(this.app, this));
    this.statusBar = this.addStatusBarItem();
    this.addCommand({
      id: "init-graph-guru",
      name: "Initialize",
      callback: async () => {
        new import_obsidian2.Notice("Initializing GraphGuru");
        const result = await this.runPython();
        if (result != null) {
          this.initBool = true;
          new import_obsidian2.Notice("GraphGuru is initialized");
          this.statusBar.setText(`GraphGuru Initialized \u2705`);
        } else {
          this.initBool = false;
          new import_obsidian2.Notice("GraphGuru is not initialized. Check developed console for errors.");
          this.statusBar.setText(`GraphGuru Not Initialized \u{1F621}`);
        }
      }
    });
    this.addRibbonIcon("map-pin", "Open GraphGuru", async () => {
      if (this.initBool) {
        new import_obsidian2.Notice("GraphGuru is initialized");
      } else {
        new import_obsidian2.Notice("GraphGuru is not initialized");
      }
    });
  }
  async runPython() {
    try {
      let options = {
        pythonPath: this.settings.pythonInterpreter,
        args: [this.baseVaultPath, this.settings.openaiAPIKey]
      };
      this.statusBar.setText(`GraphGuru Processing \u23F3`);
      const result = await import_python_shell.PythonShell.run(this.pythonScriptsPath, options);
      console.log(`Python results: ${result}`);
      return result;
    } catch (error) {
      console.log(error);
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  onunload() {
    console.log("unloading plugin");
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL3B5dGhvbi1zaGVsbC9pbmRleC50cyIsICJzcmMvbWFpbi50cyIsICJzcmMvc2V0dGluZ3MudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbbnVsbCwgImltcG9ydCB7IEZpbGVTeXN0ZW1BZGFwdGVyLCBOb3RpY2UsIFBsdWdpbiwgVEZpbGUsIENhY2hlZE1ldGFkYXRhLCBnZXRBbGxUYWdzIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgUHl0aG9uU2hlbGwgfSBmcm9tICdweXRob24tc2hlbGwnO1xuY29uc3QgeyBzcGF3biB9ID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpO1xuaW1wb3J0IHsgR3JhcGhHdXJ1U2V0dGluZ3MsIEdyYXBoR3VydVNldHRpbmdUYWIsIERlZmF1bHRHdXJ1U2V0dGluZ3MgfSBmcm9tICcuL3NldHRpbmdzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JhcGhHdXJ1UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgICBpbml0Qm9vbDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGJhc2VWYXVsdFBhdGg6IHN0cmluZztcbiAgICBweXRob25TY3JpcHRzUGF0aDogc3RyaW5nO1xuICAgIHNldHRpbmdzOiBHcmFwaEd1cnVTZXR0aW5ncztcbiAgICBzdGF0dXNCYXI6IEhUTUxFbGVtZW50O1xuXG4gICAgYXN5bmMgb25sb2FkKCkge1xuICAgICAgICBpZiAodGhpcy5hcHAudmF1bHQuYWRhcHRlciBpbnN0YW5jZW9mIEZpbGVTeXN0ZW1BZGFwdGVyKSB7XG5cdFx0XHR0aGlzLmJhc2VWYXVsdFBhdGggPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLmdldEJhc2VQYXRoKCk7XG4gICAgICAgICAgICB0aGlzLnB5dGhvblNjcmlwdHNQYXRoID0gdGhpcy5iYXNlVmF1bHRQYXRoICsgJy8ub2JzaWRpYW4vcGx1Z2lucy9vYnNpZGlhbi1ncmFwaC1ndXJ1L3NyYy9weXRob25fc2NyaXB0cy9zY3JpcHQucHknO1xuXHRcdH1cblxuICAgICAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgRGVmYXVsdEd1cnVTZXR0aW5ncywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBHcmFwaEd1cnVTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG4gICAgICAgIHRoaXMuc3RhdHVzQmFyID0gdGhpcy5hZGRTdGF0dXNCYXJJdGVtKCk7XG5cbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgICAgICAgIGlkOiAnaW5pdC1ncmFwaC1ndXJ1JyxcbiAgICAgICAgICAgIG5hbWU6ICdJbml0aWFsaXplJyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIkluaXRpYWxpemluZyBHcmFwaEd1cnVcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5ydW5QeXRob24oKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0Qm9vbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJHcmFwaEd1cnUgaXMgaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzQmFyLnNldFRleHQoYEdyYXBoR3VydSBJbml0aWFsaXplZCBcdTI3MDVgKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXdhaXQgdGhpcy53cml0ZVRvQ1NWKHRoaXMuZ3VydUNvb3JkaW5hdGVzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRCb29sID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJHcmFwaEd1cnUgaXMgbm90IGluaXRpYWxpemVkLiBDaGVjayBkZXZlbG9wZWQgY29uc29sZSBmb3IgZXJyb3JzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNCYXIuc2V0VGV4dChgR3JhcGhHdXJ1IE5vdCBJbml0aWFsaXplZCBcdUQ4M0RcdURFMjFgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICAvLyBodHRwczovL2x1Y2lkZS5kZXZcbiAgICAgICAgLy8gZ2xvYmUtMiwgbWFwLXBpbiwgYW5jaG9yLCBtYXBcbiAgICAgICAgdGhpcy5hZGRSaWJib25JY29uKFwibWFwLXBpblwiLCBcIk9wZW4gR3JhcGhHdXJ1XCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluaXRCb29sKSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIkdyYXBoR3VydSBpcyBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIkdyYXBoR3VydSBpcyBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIHJ1blB5dGhvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHB5dGhvblBhdGg6IHRoaXMuc2V0dGluZ3MucHl0aG9uSW50ZXJwcmV0ZXIsXG4gICAgICAgICAgICAgICAgYXJnczogW3RoaXMuYmFzZVZhdWx0UGF0aCwgdGhpcy5zZXR0aW5ncy5vcGVuYWlBUElLZXldXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQmFyLnNldFRleHQoYEdyYXBoR3VydSBQcm9jZXNzaW5nIFx1MjNGM2ApO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHl0aG9uU2hlbGwucnVuKHRoaXMucHl0aG9uU2NyaXB0c1BhdGgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFB5dGhvbiByZXN1bHRzOiAke3Jlc3VsdH1gKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcbiAgICB9XG5cbiAgICBvbnVubG9hZCgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3VubG9hZGluZyBwbHVnaW4nKTtcbiAgICAgICAgLy8gdW5pbnN0YWxsIHB5dGhvbiBkZXBlbmRlbmNpZXM/IG1laFxuICAgIH1cbn0iLCAiaW1wb3J0IHtBcHAsIE5vdGljZSwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZ30gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBzcGF3biwgZXhlYywgQ2hpbGRQcm9jZXNzIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5cbmltcG9ydCBHcmFwaEd1cnVQbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdyYXBoR3VydVNldHRpbmdzIHtcbiAgICBvcGVuYWlBUElLZXk6IHN0cmluZztcbiAgICBvcGVuYWlBUElLZXlTaGFkb3c6IHN0cmluZztcbiAgICBweXRob25JbnRlcnByZXRlcjogc3RyaW5nO1xuICAgIGRlcGVuZGVuY2llc0luc3RhbGxlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IERlZmF1bHRHdXJ1U2V0dGluZ3M6IEdyYXBoR3VydVNldHRpbmdzPSB7XG4gICAgb3BlbmFpQVBJS2V5OiAnJyxcbiAgICBvcGVuYWlBUElLZXlTaGFkb3c6ICcnLFxuICAgIHB5dGhvbkludGVycHJldGVyOiAncHl0aG9uJyxcbiAgICBkZXBlbmRlbmNpZXNJbnN0YWxsZWQ6IGZhbHNlLFxufSBcblxuZXhwb3J0IGNsYXNzIEdyYXBoR3VydVNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgICBwbHVnaW46IEdyYXBoR3VydVBsdWdpbjtcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IEdyYXBoR3VydVBsdWdpbikge1xuICAgICAgICBzdXBlcihhcHAsIHBsdWdpbik7XG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgIH1cblxuICAgIGRpc3BsYXkoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywge3RleHQ6ICdHcmFwaCBHdXJ1IFNldHRpbmdzJ30pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAuc2V0TmFtZSgnT3BlbkFJIEFQSSBrZXknKVxuICAgICAgICAgICAuc2V0RGVzYygnVGhpcyBrZXkgd2lsbCBiZSB1c2VkIGZvciBPcGVuQUkgQVBJIGNhbGxzLiBXZSBjYW5ub3Qgc2VlIHlvdXIga2V5LiBZb3UgY2FuIGdldCBhIGtleSBmcm9tIGh0dHBzOi8vYmV0YS5vcGVuYWkuY29tL2FjY291bnQvYXBpLWtleXMuJykgICBcbiAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4ge1xuICAgICAgICAgICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoJ0hpZGUgQVBJIGtleScpO1xuICAgICAgICAgICAgICAgYnV0dG9uLnNldEN0YSgpO1xuICAgICAgICAgICAgICAgYnV0dG9uLm9uQ2xpY2soZXZ0ID0+IHtcbiAgICAgICAgICAgICAgICAgICBsZXQgaW5wdXQgPSBjb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQudHlwZSA9PT0gJ3Bhc3N3b3JkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQudHlwZSA9ICd0ZXh0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KCdIaWRlIEFQSSBrZXknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnR5cGUgPSAncGFzc3dvcmQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoJ1Nob3cgQVBJIGtleScpO1xuICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgIH0pXG4gICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKFwiQVBJIGtleVwiKVxuICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm9wZW5haUFQSUtleSlcbiAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3BlbmFpQVBJS2V5ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnB1dCA9IGNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQudHlwZSA9ICdwYXNzd29yZCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdQeXRob24gaW50ZXJwcmV0ZXInKVxuXHRcdFx0LnNldERlc2MoJ1BhdGggdG8geW91ciBweXRob24gaW50ZXJwcmV0ZXIsIGUuZy4gYC91c3IvYmluL3B5dGhvbmAuIElmIHlvdSBhcmUgdXNpbmcgYSB2aXJ0dWFsIGVudmlyb25tZW50LCB5b3UgY2FuIGZpbmQgdGhlIHBhdGggdG8geW91ciBweXRob24gaW50ZXJwcmV0ZXIgYnkgcnVubmluZyBgd2hpY2ggcHl0aG9uYCBpbiB5b3VyIHZpcnR1YWwgZW52aXJvbm1lbnQuIFJlcXVpcmVzIFB5dGhvbiAzLjkgb3IgaGlnaGVyLicpXG5cdFx0XHQuc2V0Q2xhc3MoJ3dpZGVTZXR0aW5nc0VsZW1lbnQnKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5weXRob25JbnRlcnByZXRlcilcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnB5dGhvbkludGVycHJldGVyID0gdmFsdWU7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdH0pKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdJbnN0YWxsIHB5dGhvbiBkZXBlbmRlbmNpZXMnKVxuICAgICAgICAgICAgLnNldERlc2MoJ1RoaXMgd2lsbCBtb2RpZnkgeW91ciBlbnZpcm9ubWVudC11c2UgYXQgeW91ciBvd24gcmlzay4nKVxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4ge1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KCdJbnN0YWxsIGRlcGVuZGVuY2llcycpO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRDdGEoKTtcbiAgICAgICAgICAgICAgICBidXR0b24ub25DbGljayhldnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW50ZXJwcmV0ZXIgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5weXRob25JbnRlcnByZXRlcjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbW1hbmQgPSBgJHtpbnRlcnByZXRlcn0gLXUgLW0gcGlwIGluc3RhbGwgLS11cGdyYWRlIG9wZW5haSBudW1weSBvYnNpZGlhbnRvb2xzIHNjaWtpdC1sZWFybiB0ZW5hY2l0eSBtYXJrZG93biBweW1kb3duLWV4dGVuc2lvbnMgaHRtbDJ0ZXh0IHBhbmRhcyBudW1weSBuZXR3b3JreGA7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0luc3RhbGxpbmcgZGVwZW5kZW5jaWVzOyB0aGlzIG1heSB0YWtlIHNvbWUgdGltZS4uLicpO1xuICAgICAgICAgICAgICAgICAgICBleGVjKGNvbW1hbmQsIChlcnJvciwgc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYGZhaWxlZCB0byBpbnN0YWxsIGRlcGVuZGVuY2llczogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdGYWlsZWQgdG8gaW5zdGFsbCBkZXBlbmRlbmNpZXMsIHZpZXcgZGV2ZWxvcGVyIGNvbnNvbGUgZm9yIGRldGFpbHMuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0luc3RhbGxlZCBkZXBlbmRlbmNpZXMsIHZpZXcgZGV2ZWxvcGVyIGNvbnNvbGUgZm9yIGRldGFpbHMuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZGVwZW5kZW5jaWVzSW5zdGFsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBpbnN0YWxsIHN0ZG91dDogJHtzdGRvdXR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgaW5zdGFsbCBzdGRlcnI6ICR7c3RkZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cblxuXG5cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFFBQUEsV0FBQSxRQUFBLFFBQUE7QUFDQSxRQUFBLGtCQUFBLFFBQUEsZUFBQTtBQUNBLFFBQUEsT0FBQSxRQUFBLElBQUE7QUFDQSxRQUFBLFNBQUEsUUFBQSxNQUFBO0FBQ0EsUUFBQSxXQUFBLFFBQUEsUUFBQTtBQUNBLFFBQUEsT0FBQSxRQUFBLElBQUE7QUFDQSxRQUFBLFNBQUEsUUFBQSxNQUFBO0FBRUEsYUFBUyxRQUFXLFFBQWdCO0FBQ2hDLFVBQUksT0FBTyxXQUFXLGVBQWUsV0FBVyxNQUFNO0FBQ2xELGVBQU8sQ0FBQTtpQkFDQSxDQUFDLE1BQU0sUUFBUSxNQUFNLEdBQUc7QUFDL0IsZUFBTyxDQUFDLE1BQU07O0FBRWxCLGFBQU87SUFDWDtBQUtBLGFBQVMsT0FBTyxRQUFZLE1BQUk7QUFDNUIsWUFBTSxVQUFVLE1BQU0sS0FBSyxXQUFXLENBQUMsRUFBRSxRQUFRLFNBQVUsUUFBTTtBQUM3RCxZQUFJLFFBQVE7QUFDUixtQkFBUyxPQUFPLFFBQVE7QUFDcEIsZ0JBQUksR0FBRyxJQUFJLE9BQU8sR0FBRzs7O01BR2pDLENBQUM7QUFDRCxhQUFPO0lBQ1g7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O0FBRU0sU0FBSyxXQUFXLE9BQU8sT0FBTyxDQUFDLEdBQUcscUJBQXFCLE1BQU0sS0FBSyxTQUFTLENBQUM7QUFDNUUsVUFBTSxLQUFLLGFBQWE7QUFDeEIsU0FBSyxjQUFjLElBQUksb0JBQW9CLEtBQUssS0FBSyxJQUFJLENBQUM7QUFDMUQsU0FBSyxZQUFZLEtBQUssaUJBQWlCO0FBRXZDLFNBQUssV0FBVztBQUFBLE1BQ1osSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxZQUFZO0FBQ2xCLFlBQUksd0JBQU8sd0JBQXdCO0FBQ25DLGNBQU0sU0FBUyxNQUFNLEtBQUssVUFBVTtBQUNwQyxZQUFJLFVBQVUsTUFBTTtBQUNoQixlQUFLLFdBQVc7QUFDaEIsY0FBSSx3QkFBTywwQkFBMEI7QUFDckMsZUFBSyxVQUFVLFFBQVEsOEJBQXlCO0FBQUEsUUFFcEQsT0FBTztBQUNILGVBQUssV0FBVztBQUNoQixjQUFJLHdCQUFPLG1FQUFtRTtBQUM5RSxlQUFLLFVBQVUsUUFBUSxxQ0FBOEI7QUFBQSxRQUN6RDtBQUFBLE1BQ0o7QUFBQSxJQUNKLENBQUM7QUFJRCxTQUFLLGNBQWMsV0FBVyxrQkFBa0IsWUFBWTtBQUN4RCxVQUFJLEtBQUssVUFBVTtBQUNmLFlBQUksd0JBQU8sMEJBQTBCO0FBQUEsTUFDekMsT0FBTztBQUNILFlBQUksd0JBQU8sOEJBQThCO0FBQUEsTUFDN0M7QUFBQSxJQUNKLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFFQSxNQUFNLFlBQVk7QUFDZCxRQUFJO0FBQ0EsVUFBSSxVQUFVO0FBQUEsUUFDVixZQUFZLEtBQUssU0FBUztBQUFBLFFBQzFCLE1BQU0sQ0FBQyxLQUFLLGVBQWUsS0FBSyxTQUFTLFlBQVk7QUFBQSxNQUN6RDtBQUVBLFdBQUssVUFBVSxRQUFRLDZCQUF3QjtBQUMvQyxZQUFNLFNBQVMsTUFBTSxnQ0FBWSxJQUFJLEtBQUssbUJBQW1CLE9BQU87QUFDcEUsY0FBUSxJQUFJLG1CQUFtQixRQUFRO0FBRXZDLGFBQU87QUFBQSxJQUNYLFNBQVMsT0FBUDtBQUNFLGNBQVEsSUFBSSxLQUFLO0FBQUEsSUFDckI7QUFBQSxFQUNKO0FBQUEsRUFFQSxNQUFNLGVBQWU7QUFDakIsVUFBTSxLQUFLLFNBQVMsS0FBSyxRQUFRO0FBQUEsRUFDckM7QUFBQSxFQUVBLFdBQVc7QUFDUCxZQUFRLElBQUksa0JBQWtCO0FBQUEsRUFFbEM7QUFDSjsiLAogICJuYW1lcyI6IFsiUHl0aG9uU2hlbGwiLCAiaW1wb3J0X29ic2lkaWFuIiwgInNwYXduIl0KfQo=
